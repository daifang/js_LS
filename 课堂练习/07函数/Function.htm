<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Function</title>
</head>
<body>
    <script>
        //JS的可以将所有定义都提前，就是将所有的变量都放在最开始的位置,所以后两种函数定义方法,
        //只是将var fun;提前了 并没有把函数的内容提前所以不可以进行提前调用

        //函数定义三种方式
        //<---一--->    可以在函数体之前进行调用
        //fun(1,1);
        //function fun (a,b){return a+b;}

        //<---二--->  不能在函数声明前进行调用
        //var fun = function(a,b){return a+b;}
        //fun(1,2);

        //<---三--->    构造函数进行实例化,也不可以提前调用   最后一个参数为函数内容，其他的都是形参
        //执行效率相对较低，因为这个方法有一个实例化的过程
        //console.log(fun(1,2));//报错，参见第一句话
        var fun = new Function("a","b","return a+b;");//  f 大写  Function  所有都有引号    " "
        
        //移花接木，call方法就是把别人的方法使用在自己体内，apply方法也可以达到同样效果
        var objA = {"name":"AAA"}
        var objB = {"name":"BBB"}
        objA.test = function(){console.log(this.name)}
        objA.test();
        objA.test.call(objB);//使当前对象变成了BBB，让test方法作用在objB对象上



        function Person(name)
        {
            this.name = name;
        }

        Person.prototype.sayHi = function(){
            console.log("Hi,i'm "+this.name);
        };
        var p1 = new Person("Jack");
        p1.sayHi();//Hi,i'm Jack

       //函数arguments属性，是类数组的结构
       //用该属性获取实参

       function A(){
            var s='';
            for(i in arguments){
                s+=arguments[i];
            }
           return s;
       }
       console.log(A());
    </script>

</body>
</html>