# 第一章
## 软件包括 
   程序 数据 及 相关文档 的集合
## 软件的特点
   * 逻辑实体而不是物理实体
   * 存在退化 不存在老化 需要维护
   * 制作复杂
   * 成本较高
   * 大多软件是自定义的，而不是通过组装完成
## 软件危机（选择填空）、表现、原因、存在价值
   * 定义 : 软件在开发和维护过程中遇到的一系列 严重问题
   * 开发软件  和   维护已有的大量软件
   * 表现
      * 开发进度难以控制
      * 后期维护困难
      * 开发成本昂贵
      * 需求不明确
      * 相关文档不完整，不合格
   * 原因
      * 客户对自己的需求表达不清，二义性，错误性
      * 开发者对需求的理解和客户本意不太一致
      * 管理人员和开发者之间的交流出现误解
      * 缺乏正确的方法和高效率的工具，过分依靠开发者的自由创造
   * 存在价值
      * 促进软件项目成功
## 基本概念
   * 研究和应用如何以系统化的、规范的、可度量的方法去开发、运行、和维护软件，即把工程化应用到软件上
## 软件的生存周期、各个阶段的主要任务
   * 生存周期
      * 计划

      * 分析

      * 设计

      * 实现

      * 测试

      * 集成

      * 交付

      * 维护···

   * 各阶段主要任务
      * 计划阶段
         * 确定开发的总体目标和范围
         * 研究项目可行性，对资源、成本进行预估
      * 分析阶段
         * 分析用户需求，编写需求文档
      * 设计阶段
         * 决定如何去做
         * 主要决定 软件体系结构、数据结构、用户界面和算法···
      * 实现阶段
         * 编写程序
      * 测试阶段
         * 软件测试，找出问题，即使改正
      * 运行和维护阶段
         * 测试是否完成了需求的修改，并保证修改过程不影响其他功能
         * 维护是最有挑战性的阶段，并且费用很昂贵

## 软件工程三要素
   * 工具(系统) XMind、JIRA、MoinMoin···
   * 方法(技能) UML
   * 开发过程(框架) 业务建模、需求、分析、设计、实施、发布
## 瀑布模型
   * 问题定义
   * 可行性研究
   * 需求分析
   * 概要设计
   * 详细设计
   * 编码
   * 测试
   * 运行和维护
   * ### 特点
      * 自上而下、相互衔接、固定次序、逐级下落
      * 相邻两阶有因果关系
   * ### 问题
      * 极大增加工作量
      * 开发是线性的，增加了风险
      * 早期的错误可能要到测试阶段才能发现，后果严重 
## RUP 统一软件过程（填空）
   * 中心思想
      * 用例驱动
      * 架构为中心
      * 迭代和增量
## scrum（综合简答）
   * 负责人建立条目化的产品待开发项，并进行优先级排序
   * 迭代计划会上讲解本次迭代开发的条目，团队进行估算并放入下一个迭代
   * 每天开日立会，沟通进度问题
   * 迭代评审会，展示开发成果
## UML（UnifiedModelingLanguage）
   * 语言是用来表达和沟通思想的，UML承载着OOAD的思想
   * UML静态图
      * 类图
      * 对象图
      * 组件图
      * 部署图
   * UML动态图
      * 时序图
      * 协作图
      * 状态图
      * 活动图
      * 用例图
## ICONIX 画图
   * 愿景
   * 业务建模
   * 需求分析
   * 健壮性分析
   * 关键设计
   * 最终设计
   * 实现
## 迭代与增量
   * 增量:逐块建造
   * 迭代:反复求精
****
# 第二章

## ICONIX过程
   * ### 愿景、业务建模、需求分析、健壮性分析、关键设计、最终设计、实现
   * ### 需求阶段、系统的设计和实现阶段
   * ### 需求分析阶段、初步设计阶段、详细设计阶段、部署阶段
   * ### 特点
      * 尽早进入编码阶段
      * 合理的简化统一过程(RUP)，基于敏捷开发思想
      * 与RUP对比，是轻量级的，与敏捷相比，ICONIX提供充足的需求和设计文档，但不过度分析设计
      * ICONIX从需求到代码需要四个步骤
         * 用例图
         * 序列图
         * 类图
         * 健壮性图(非UML标准)
## 愿景的三个步骤、愿景不是功能，也不是组织目标
   * 找到软件项目‘老大’
      * 如何找‘老大’(要改善的组织中最有权力的干系人)
   * 得到‘老大’对项目的期望(愿景)
      * 软件项目愿景:‘老大’愿意掏钱开发这个系统的目的
   * 描述愿景的度量指标
      * 不是做具体的事，而是改善组织的指标(关键字:`减少`，`提高`，`增强`，`缩短`···)
   * 愿景的度量指标主要关注
      * 利润 = 收入 - 支出
      * 买了这个系统对组织有什么好处

# (*重点*) 第三章
## 重点：业务建模
   * 把视角从软件刺痛转向客户组织，站在客户角度看问题
## 业务建模的意义
   * 明确为谁服务 -- 找准`客户`及其`愿景`，而不是靠自己的想法进行‘创造’
   * 要改进的组织是什么现状 -- 有什么`痛处`和`不足`
   * 如何`改进` -- 新系统的价值就是解决客户痛处、改良客户不足
   * 在业务建模和需求分析阶段，忘掉自己技术专家的身份

## 业务建模的步骤（与意义相对应）
   * 明确我们为谁服务 -- 选定愿景要改进的组织
      * 根据题意找出我们为谁服务
   * 要改进的组织是什么现状 -- 业务用例图、现状业务序列图
      * 从外部看:组织是`价值`的集合，用业务用例图建模
      * 从内部看:组织是`系统`的集合(人是一种智能系统)，用业务序列图来建模
   * 我们如何改进 -- 改进业务序列图
      * 业务序列图帮助我们从`细节上`了解组织的业务流程
      * 了解业务组织现状的目的 -- 发现流程中的改进点
      * 具体分析流程中的改进点
      * ## 价值
         * 业务序列图展现现有业务流程，暴露问题，为优化提供直观依据
         * 通过更改业务序列，可以提前模拟出新系统的出现会对流程的影响，可以提前评估新系统的可行性


        
## 业务用例图
   * 业务用例图帮助我们从`高层次`了解组织的`业务构成`
   * ### 组成
      * 业务执行者(在业务组织之外，与其交互，享受价值的人或组织)
         * 例如:存款人是银行的业务执行者
      * 业务组织
         * 
      * 业务用例
         * 业务组织为业务执行者提供的价值，如:银行提供了 存取款、贷款··· 餐厅提供吃饭
         * 编写用例
            * 业务执行者 + 业务组织的约定 = 某个固有目的
         * 简述
            * 如 ，银行客户于银行营业时间，到银行营业厅，在银行柜员协助下办理取款业务
         
## 序列图
   * 以面向对象思想来看业务流程
   * 业务工人
      * 银行柜员、医院医生、餐厅服务员
   * 业务执行者
      * 存款人、病人、饿货
   * 业务实体
      * 使用的系统，业务办理机、学校校园卡系统、医院信息系统、餐厅刷卡系统
   * ## 作用
      * 识别业务对象:业务执行者、业务工人、业务实体
      * 确定业务对象间的职责、协作、及交互顺序
      * 通过序列图来了解现状，为业务的优化提供依据

# (*重点*)第四章

## 系统用例
   * 银行的更改账户信息，添加账户，删除账户···
## 用例描述
   * 
## 域模型
   * 意义
      * 为项目创建一个术语表，确保项目中每个人都能用清晰一致的术语来理解和交流问题领域(统一术语)
      * 以图的形式清晰地显示出不同术语间的关系(减少理解偏差)
   * 步骤
      * 阅读需求文档，提取名词和名词短语
      * 排除重复 相似术语
      * 排除超系统范围的术语
      * 画出第一版域模型
      * 整理第一版域模型
   * 域模型之间的关系
      * `泛化`，一般元素和特殊元素
      * `关联`，两个类之间存在某种语义上的联系
   * 域建模的重要原则
      * 不要花费太多的时间纠缠在最初的域建模工作上
      * 不要把域模型错误地认为是数据结构
      * 在用例分析前做域建模，避免命名混淆
      * 不要把界面相关的类加入域模型
      * 不要指望最终的类试图和域模型完全匹配，但他们很大程度上是类似的
   * 系统用例建模的意义
      * 系统需求分析的目的是把视角从业务组织转向新系统，站在最终用户及其它干系人的角度看问题
      * 系统用例是对新系统为系统执行者提供的价值的建模
## 非功能性需求：可靠性、可用性、性能、可支持性

# 第五章
## 系统用例建模步骤
   * 绘制系统用例图
   * 编写系统用例描述
   * 更新域模型
## 健壮性分析的优点
   * 用例的对象化图示，将用例和对象链接起来
   * 指出了参与用例场景的对象相互之间如何交互
   * 确保用力文本的正确性，提供健康性检查
   * 让你能持续发现对象
   * 缩小分析和设计的鸿沟
## 健壮性分析三种元素
   * 边界类
   * 实体类
   * 控制器类
## 交互规则
   1. 执行者只能和边界对象通话
   2. 边界对象和控制器可以相互通话
   3. 控制器可以和控制器通话
   4. 控制器可以和实体对象通话
## 健壮性分析的步骤
   1. 创建空健壮性图
   2. 基本路径和扩展路径
   3. 从基本路径第一句话开始画健壮性图
   4. 画执行者，边界对象 实体对象 控制器 ，连线
   5. 扩展路径并标红
# 第六章
## 关键设计意义
   * 要通过寻找对象之间的交互关系，进行方法分配
## 关键设计步骤
   1. 将现有域模型直接作为第一版静态模型
   2. 基于用例描述和健壮性分析结果，画出每个用例的序列图
      * 见状性图中的控制类会转化为方法
      * 如果也转化为控制类，那就添加到类图中(PS:边界类不添加到类图中)
   3. 整理
   4. 关键设计复核，迭代更新用例图、类图、序列图

# 第七章

# 第八章
## 敏捷宣言  内容
   * 个体和交互 -胜过- 过程和工具
   * 可以工作的软件 -胜过- 面面俱到的文档
   * 客户合作 -胜过- 合作谈判
   * 相应变化 -胜过- 遵循计划
   * 左方对比于右方有更大价值
## 常见误解
   * 不需要文档、设计、计划  (X)
   * 敏捷只是一些优秀实践，或者是优秀实践的结合(X)
   * 敏捷只适合小项目开发
   * 敏捷只会对研发产生改变
   * 管理者不需要亲自了解敏捷，只需要管理上的支持
   * 敏捷开发只需要按既定的步骤去做就可以了
   * 敏捷只是CMM的替代品
   * 敏捷只注重特性的快速交付，在敏捷下架构不重要
## 统一认识： 敏捷 = 理念 + 优秀实践 + 具体应用
   * 理念 ---- 核心思想
   * 优秀实践 ---- 经验积累
   * 具体应用 ---- 灵活运用
## SCRUM 三种角色 (PO-业务负责人，SM-Scrum教练，Team-团队)
   * PO
      * 监督Team做正确的事
   * SM
      * 监督Team做正确的事，但是他不能命令团队
   * Team
      * 负责产品的实现
## 敏捷软件开发过程 七个步骤
   1. PO和Team对业务目的达成共识 -- PO 和 团队达成一致
   2. PO创建并维护需求列表，并标识优先级 -- 编写并维护需求文档(带优先级)
   3. PO每次迭代前，Review(回顾)需求列表，挑选高优先级任务进行迭代 -- 高优先级进行迭代
   4. 团队按优先级进行开发选出来的迭代任务 -- 团队对PO挑选的任务进行二次优先级分析
   5. 团队日立会，特性开发 储蓄继承 使开发进度透明 -- 日立会
   6. PO对迭代交付的成果现场验收 -- 当场验收交付成果
   7. 团队反思本次迭代的问题和不足 -- 反思进步
## 完整小队(特种兵小组)
   * ### 坐在一起工作，密切协同，服从一个项目经理
   * 成员来自多功能领域
   * 坐在一起办公
   * 团队保持相对稳定
   * 每个人一专多能，互助互补
   * ## 优点
      * 提升开发效率
      * 高度协同，短期交付任务
      * 促进各功能领域的拉通和融合
## 完成标准
   * 基于"随时都能向用户发布"的目标来衡量
## 日立会
   * 充分参与:PO和Team进行充分讨论
   * 相互承诺:PO承诺短时间内不更改需求，Team承诺完成相应的迭代任务
   * 确定内部认为:Team和PO协商把内部任务放到迭代任务中(环境搭建、重构···)
## 迭代周期 2-4周
   * PO:定制目标，回答团队提出的问题
   * Team:确定可以完成哪些任务，冲刺规划结束时承诺
   * SM:观察规划，提出深入细节的问题

## user story
   * 站在用户角度描述需求
   * 作为 \*** 的用户，我想用 \*** 的功能,满足我***的需求
   * 故事分解(说白了就是细化)
      * 初次
      * 再次
   * 史诗故事 -- 1-2/月   --- 由许多基础故事组合而成
   * 特性故事 -- 1-2/周   --- 
   * 冲刺故事 -- 1-2/天   --- 
   * 任务 -- 几个小时     --- 可分工
   * ### INVEST标准
      * 独立、可协商、有价值、可估算、大小合适、可测试
## 非功能性需求
   * 比如: 语言支持，兼容性···
## 收集用户故事
   * 开会讨论，PO、SM、Team、内部干系人、用户均可参与
   * 方法:头脑风暴、人物角色、思维导图、故事地图
   * 时间:几小时-几天
      * 故事地图
         * 史诗故事按时间横向排列
         * 纵向按优先级排列 

# 敏捷工程实践技术
1. ## 结对编程
   * 一个敲代码一个看着，好比考科三时候，旁边的安全员
   * 好处
      * 生产率虽然低，但是质量大大增加
2. ##  测试驱动开发(TDD)
   * 要求
      * 测试前先定义测试用例
      * 代码通过用例
      * 不断重构优化
      * 测试自动化
   * 代码要求
      * 测试代码简洁，可读性好
      * 测试用例要考虑完备
      * 测试用例尽量独立
      * 测试功能较大时，可以拆解
   * 好处
      * 保证代码重构质量
      * 提高代码可测试性 
3. ## 持续集成
   * Team应该经常进行集成，每人每天至少一次
   * 优点
      * 问题当天就可以发现并及时解决
      * 避免了最终集成时爆发大量问题
      * 大幅度缩短反馈周期，实时反映产品真实质量
   * 要点
      * 集成时间尽量短
      * 在本地构建成功后才能交到代码库
      * 大系统持续集成需要分层分级
4. ## Code Review (旁观者清)
   * 目的 ： 持续提高开发团队工作质量
   * 好处 ： 代码审查者可以发现一些问题并提出建议，确保了团队另一个人了解你的代码，公开代码可以分享知识，积极性提高，因为代码会被公开
5. ## 产品发布规则
   * 每次迭代发布
      * 移动互联网产品
      * 自主性研发产品
   * 多次迭代发布
      * 传统项目
      * 大型项目

